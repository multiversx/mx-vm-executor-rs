// Code generated by vmhooks generator. DO NOT EDIT.

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!!!!!!!!!!!!!!!!!!!!! AUTO-GENERATED FILE !!!!!!!!!!!!!!!!!!!!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

use std::{cell::RefCell, ffi::c_void};

use crate::{MemLength, MemPtr, VMHooks, VMHooksEarlyExit, VMHooksLegacy};

/// Allows VM hooks handler to define an early exit method to be used by the VMHooksLegacyAdapter.
pub trait VMHooksSetEarlyExit: VMHooks {
    fn set_early_exit(&self, early_exit: VMHooksEarlyExit);
}

/// Allow conversion from the new VMHooks to the old.
///
/// Will eventually be removed, once everything gets migrated.
#[derive(Debug)]
pub struct VMHooksLegacyAdapter<VH: VMHooksSetEarlyExit> {
    inner_cell: RefCell<VH>,
}

impl<VH: VMHooksSetEarlyExit> VMHooksLegacyAdapter<VH> {
    pub fn new(inner: VH) -> Self {
        VMHooksLegacyAdapter {
            inner_cell: RefCell::new(inner),
        }
    }

    fn adapt_vm_hooks<F, R>(&self, f: F) -> R
    where
        R: Default,
        F: FnOnce(&mut dyn VMHooks) -> Result<R, VMHooksEarlyExit>,
    {
        let mut vm_hooks = self.inner_cell.borrow_mut();
        let result = f(&mut *vm_hooks);
        result.unwrap_or_else(|early_exit| {
            vm_hooks.set_early_exit(early_exit);
            R::default()
        })
    }
}

#[rustfmt::skip]
impl<VH: VMHooksSetEarlyExit> VMHooksLegacy for VMHooksLegacyAdapter<VH> {
    fn set_vm_hooks_ptr(&mut self, _vm_hooks_ptr: *mut c_void) {
    }

    fn get_gas_left(&self) -> i64 {
        self.adapt_vm_hooks(|inner| VMHooks::get_gas_left(inner))
    }

    fn get_sc_address(&self, result_offset: MemPtr) {
        self.adapt_vm_hooks(|inner| VMHooks::get_sc_address(inner, result_offset))
    }

    fn get_owner_address(&self, result_offset: MemPtr) {
        self.adapt_vm_hooks(|inner| VMHooks::get_owner_address(inner, result_offset))
    }

    fn get_shard_of_address(&self, address_offset: MemPtr) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::get_shard_of_address(inner, address_offset))
    }

    fn is_smart_contract(&self, address_offset: MemPtr) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::is_smart_contract(inner, address_offset))
    }

    fn signal_error(&self, message_offset: MemPtr, message_length: MemLength) {
        self.adapt_vm_hooks(|inner| VMHooks::signal_error(inner, message_offset, message_length))
    }

    fn get_external_balance(&self, address_offset: MemPtr, result_offset: MemPtr) {
        self.adapt_vm_hooks(|inner| VMHooks::get_external_balance(inner, address_offset, result_offset))
    }

    fn get_block_hash(&self, nonce: i64, result_offset: MemPtr) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::get_block_hash(inner, nonce, result_offset))
    }

    fn get_esdt_balance(&self, address_offset: MemPtr, token_id_offset: MemPtr, token_id_len: MemLength, nonce: i64, result_offset: MemPtr) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::get_esdt_balance(inner, address_offset, token_id_offset, token_id_len, nonce, result_offset))
    }

    fn get_esdt_nft_name_length(&self, address_offset: MemPtr, token_id_offset: MemPtr, token_id_len: MemLength, nonce: i64) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::get_esdt_nft_name_length(inner, address_offset, token_id_offset, token_id_len, nonce))
    }

    fn get_esdt_nft_attribute_length(&self, address_offset: MemPtr, token_id_offset: MemPtr, token_id_len: MemLength, nonce: i64) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::get_esdt_nft_attribute_length(inner, address_offset, token_id_offset, token_id_len, nonce))
    }

    fn get_esdt_nft_uri_length(&self, address_offset: MemPtr, token_id_offset: MemPtr, token_id_len: MemLength, nonce: i64) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::get_esdt_nft_uri_length(inner, address_offset, token_id_offset, token_id_len, nonce))
    }

    fn get_esdt_token_data(&self, address_offset: MemPtr, token_id_offset: MemPtr, token_id_len: MemLength, nonce: i64, value_handle: i32, properties_offset: MemPtr, hash_offset: MemPtr, name_offset: MemPtr, attributes_offset: MemPtr, creator_offset: MemPtr, royalties_handle: i32, uris_offset: MemPtr) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::get_esdt_token_data(inner, address_offset, token_id_offset, token_id_len, nonce, value_handle, properties_offset, hash_offset, name_offset, attributes_offset, creator_offset, royalties_handle, uris_offset))
    }

    fn get_esdt_local_roles(&self, token_id_handle: i32) -> i64 {
        self.adapt_vm_hooks(|inner| VMHooks::get_esdt_local_roles(inner, token_id_handle))
    }

    fn validate_token_identifier(&self, token_id_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::validate_token_identifier(inner, token_id_handle))
    }

    fn transfer_value(&self, dest_offset: MemPtr, value_offset: MemPtr, data_offset: MemPtr, length: MemLength) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::transfer_value(inner, dest_offset, value_offset, data_offset, length))
    }

    fn transfer_value_execute(&self, dest_offset: MemPtr, value_offset: MemPtr, gas_limit: i64, function_offset: MemPtr, function_length: MemLength, num_arguments: i32, arguments_length_offset: MemPtr, data_offset: MemPtr) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::transfer_value_execute(inner, dest_offset, value_offset, gas_limit, function_offset, function_length, num_arguments, arguments_length_offset, data_offset))
    }

    fn transfer_esdt_execute(&self, dest_offset: MemPtr, token_id_offset: MemPtr, token_id_len: MemLength, value_offset: MemPtr, gas_limit: i64, function_offset: MemPtr, function_length: MemLength, num_arguments: i32, arguments_length_offset: MemPtr, data_offset: MemPtr) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::transfer_esdt_execute(inner, dest_offset, token_id_offset, token_id_len, value_offset, gas_limit, function_offset, function_length, num_arguments, arguments_length_offset, data_offset))
    }

    fn transfer_esdt_nft_execute(&self, dest_offset: MemPtr, token_id_offset: MemPtr, token_id_len: MemLength, value_offset: MemPtr, nonce: i64, gas_limit: i64, function_offset: MemPtr, function_length: MemLength, num_arguments: i32, arguments_length_offset: MemPtr, data_offset: MemPtr) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::transfer_esdt_nft_execute(inner, dest_offset, token_id_offset, token_id_len, value_offset, nonce, gas_limit, function_offset, function_length, num_arguments, arguments_length_offset, data_offset))
    }

    fn multi_transfer_esdt_nft_execute(&self, dest_offset: MemPtr, num_token_transfers: i32, token_transfers_args_length_offset: MemPtr, token_transfer_data_offset: MemPtr, gas_limit: i64, function_offset: MemPtr, function_length: MemLength, num_arguments: i32, arguments_length_offset: MemPtr, data_offset: MemPtr) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::multi_transfer_esdt_nft_execute(inner, dest_offset, num_token_transfers, token_transfers_args_length_offset, token_transfer_data_offset, gas_limit, function_offset, function_length, num_arguments, arguments_length_offset, data_offset))
    }

    fn create_async_call(&self, dest_offset: MemPtr, value_offset: MemPtr, data_offset: MemPtr, data_length: MemLength, success_offset: MemPtr, success_length: MemLength, error_offset: MemPtr, error_length: MemLength, gas: i64, extra_gas_for_callback: i64) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::create_async_call(inner, dest_offset, value_offset, data_offset, data_length, success_offset, success_length, error_offset, error_length, gas, extra_gas_for_callback))
    }

    fn set_async_context_callback(&self, callback: MemPtr, callback_length: MemLength, data: MemPtr, data_length: MemLength, gas: i64) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::set_async_context_callback(inner, callback, callback_length, data, data_length, gas))
    }

    fn upgrade_contract(&self, dest_offset: MemPtr, gas_limit: i64, value_offset: MemPtr, code_offset: MemPtr, code_metadata_offset: MemPtr, length: MemLength, num_arguments: i32, arguments_length_offset: MemPtr, data_offset: MemPtr) {
        self.adapt_vm_hooks(|inner| VMHooks::upgrade_contract(inner, dest_offset, gas_limit, value_offset, code_offset, code_metadata_offset, length, num_arguments, arguments_length_offset, data_offset))
    }

    fn upgrade_from_source_contract(&self, dest_offset: MemPtr, gas_limit: i64, value_offset: MemPtr, source_contract_address_offset: MemPtr, code_metadata_offset: MemPtr, num_arguments: i32, arguments_length_offset: MemPtr, data_offset: MemPtr) {
        self.adapt_vm_hooks(|inner| VMHooks::upgrade_from_source_contract(inner, dest_offset, gas_limit, value_offset, source_contract_address_offset, code_metadata_offset, num_arguments, arguments_length_offset, data_offset))
    }

    fn delete_contract(&self, dest_offset: MemPtr, gas_limit: i64, num_arguments: i32, arguments_length_offset: MemPtr, data_offset: MemPtr) {
        self.adapt_vm_hooks(|inner| VMHooks::delete_contract(inner, dest_offset, gas_limit, num_arguments, arguments_length_offset, data_offset))
    }

    fn async_call(&self, dest_offset: MemPtr, value_offset: MemPtr, data_offset: MemPtr, length: MemLength) {
        self.adapt_vm_hooks(|inner| VMHooks::async_call(inner, dest_offset, value_offset, data_offset, length))
    }

    fn get_argument_length(&self, id: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::get_argument_length(inner, id))
    }

    fn get_argument(&self, id: i32, arg_offset: MemPtr) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::get_argument(inner, id, arg_offset))
    }

    fn get_function(&self, function_offset: MemPtr) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::get_function(inner, function_offset))
    }

    fn get_num_arguments(&self) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::get_num_arguments(inner))
    }

    fn storage_store(&self, key_offset: MemPtr, key_length: MemLength, data_offset: MemPtr, data_length: MemLength) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::storage_store(inner, key_offset, key_length, data_offset, data_length))
    }

    fn storage_load_length(&self, key_offset: MemPtr, key_length: MemLength) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::storage_load_length(inner, key_offset, key_length))
    }

    fn storage_load_from_address(&self, address_offset: MemPtr, key_offset: MemPtr, key_length: MemLength, data_offset: MemPtr) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::storage_load_from_address(inner, address_offset, key_offset, key_length, data_offset))
    }

    fn storage_load(&self, key_offset: MemPtr, key_length: MemLength, data_offset: MemPtr) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::storage_load(inner, key_offset, key_length, data_offset))
    }

    fn set_storage_lock(&self, key_offset: MemPtr, key_length: MemLength, lock_timestamp: i64) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::set_storage_lock(inner, key_offset, key_length, lock_timestamp))
    }

    fn get_storage_lock(&self, key_offset: MemPtr, key_length: MemLength) -> i64 {
        self.adapt_vm_hooks(|inner| VMHooks::get_storage_lock(inner, key_offset, key_length))
    }

    fn is_storage_locked(&self, key_offset: MemPtr, key_length: MemLength) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::is_storage_locked(inner, key_offset, key_length))
    }

    fn clear_storage_lock(&self, key_offset: MemPtr, key_length: MemLength) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::clear_storage_lock(inner, key_offset, key_length))
    }

    fn get_caller(&self, result_offset: MemPtr) {
        self.adapt_vm_hooks(|inner| VMHooks::get_caller(inner, result_offset))
    }

    fn check_no_payment(&self) {
        self.adapt_vm_hooks(|inner| VMHooks::check_no_payment(inner))
    }

    fn get_call_value(&self, result_offset: MemPtr) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::get_call_value(inner, result_offset))
    }

    fn get_esdt_value(&self, result_offset: MemPtr) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::get_esdt_value(inner, result_offset))
    }

    fn get_esdt_value_by_index(&self, result_offset: MemPtr, index: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::get_esdt_value_by_index(inner, result_offset, index))
    }

    fn get_esdt_token_name(&self, result_offset: MemPtr) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::get_esdt_token_name(inner, result_offset))
    }

    fn get_esdt_token_name_by_index(&self, result_offset: MemPtr, index: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::get_esdt_token_name_by_index(inner, result_offset, index))
    }

    fn get_esdt_token_nonce(&self) -> i64 {
        self.adapt_vm_hooks(|inner| VMHooks::get_esdt_token_nonce(inner))
    }

    fn get_esdt_token_nonce_by_index(&self, index: i32) -> i64 {
        self.adapt_vm_hooks(|inner| VMHooks::get_esdt_token_nonce_by_index(inner, index))
    }

    fn get_current_esdt_nft_nonce(&self, address_offset: MemPtr, token_id_offset: MemPtr, token_id_len: MemLength) -> i64 {
        self.adapt_vm_hooks(|inner| VMHooks::get_current_esdt_nft_nonce(inner, address_offset, token_id_offset, token_id_len))
    }

    fn get_esdt_token_type(&self) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::get_esdt_token_type(inner))
    }

    fn get_esdt_token_type_by_index(&self, index: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::get_esdt_token_type_by_index(inner, index))
    }

    fn get_num_esdt_transfers(&self) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::get_num_esdt_transfers(inner))
    }

    fn get_call_value_token_name(&self, call_value_offset: MemPtr, token_name_offset: MemPtr) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::get_call_value_token_name(inner, call_value_offset, token_name_offset))
    }

    fn get_call_value_token_name_by_index(&self, call_value_offset: MemPtr, token_name_offset: MemPtr, index: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::get_call_value_token_name_by_index(inner, call_value_offset, token_name_offset, index))
    }

    fn is_reserved_function_name(&self, name_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::is_reserved_function_name(inner, name_handle))
    }

    fn write_log(&self, data_pointer: MemPtr, data_length: MemLength, topic_ptr: MemPtr, num_topics: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::write_log(inner, data_pointer, data_length, topic_ptr, num_topics))
    }

    fn write_event_log(&self, num_topics: i32, topic_lengths_offset: MemPtr, topic_offset: MemPtr, data_offset: MemPtr, data_length: MemLength) {
        self.adapt_vm_hooks(|inner| VMHooks::write_event_log(inner, num_topics, topic_lengths_offset, topic_offset, data_offset, data_length))
    }

    fn get_block_timestamp(&self) -> i64 {
        self.adapt_vm_hooks(|inner| VMHooks::get_block_timestamp(inner))
    }

    fn get_block_timestamp_ms(&self) -> i64 {
        self.adapt_vm_hooks(|inner| VMHooks::get_block_timestamp_ms(inner))
    }

    fn get_block_nonce(&self) -> i64 {
        self.adapt_vm_hooks(|inner| VMHooks::get_block_nonce(inner))
    }

    fn get_block_round(&self) -> i64 {
        self.adapt_vm_hooks(|inner| VMHooks::get_block_round(inner))
    }

    fn get_block_epoch(&self) -> i64 {
        self.adapt_vm_hooks(|inner| VMHooks::get_block_epoch(inner))
    }

    fn get_block_random_seed(&self, pointer: MemPtr) {
        self.adapt_vm_hooks(|inner| VMHooks::get_block_random_seed(inner, pointer))
    }

    fn get_state_root_hash(&self, pointer: MemPtr) {
        self.adapt_vm_hooks(|inner| VMHooks::get_state_root_hash(inner, pointer))
    }

    fn get_prev_block_timestamp(&self) -> i64 {
        self.adapt_vm_hooks(|inner| VMHooks::get_prev_block_timestamp(inner))
    }

    fn get_prev_block_timestamp_ms(&self) -> i64 {
        self.adapt_vm_hooks(|inner| VMHooks::get_prev_block_timestamp_ms(inner))
    }

    fn get_prev_block_nonce(&self) -> i64 {
        self.adapt_vm_hooks(|inner| VMHooks::get_prev_block_nonce(inner))
    }

    fn get_prev_block_round(&self) -> i64 {
        self.adapt_vm_hooks(|inner| VMHooks::get_prev_block_round(inner))
    }

    fn get_prev_block_epoch(&self) -> i64 {
        self.adapt_vm_hooks(|inner| VMHooks::get_prev_block_epoch(inner))
    }

    fn get_prev_block_random_seed(&self, pointer: MemPtr) {
        self.adapt_vm_hooks(|inner| VMHooks::get_prev_block_random_seed(inner, pointer))
    }

    fn get_block_round_time_ms(&self) -> i64 {
        self.adapt_vm_hooks(|inner| VMHooks::get_block_round_time_ms(inner))
    }

    fn epoch_start_block_time_stamp_ms(&self) -> i64 {
        self.adapt_vm_hooks(|inner| VMHooks::epoch_start_block_time_stamp_ms(inner))
    }

    fn epoch_start_block_nonce(&self) -> i64 {
        self.adapt_vm_hooks(|inner| VMHooks::epoch_start_block_nonce(inner))
    }

    fn epoch_start_block_round(&self) -> i64 {
        self.adapt_vm_hooks(|inner| VMHooks::epoch_start_block_round(inner))
    }

    fn finish(&self, pointer: MemPtr, length: MemLength) {
        self.adapt_vm_hooks(|inner| VMHooks::finish(inner, pointer, length))
    }

    fn execute_on_same_context(&self, gas_limit: i64, address_offset: MemPtr, value_offset: MemPtr, function_offset: MemPtr, function_length: MemLength, num_arguments: i32, arguments_length_offset: MemPtr, data_offset: MemPtr) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::execute_on_same_context(inner, gas_limit, address_offset, value_offset, function_offset, function_length, num_arguments, arguments_length_offset, data_offset))
    }

    fn execute_on_dest_context(&self, gas_limit: i64, address_offset: MemPtr, value_offset: MemPtr, function_offset: MemPtr, function_length: MemLength, num_arguments: i32, arguments_length_offset: MemPtr, data_offset: MemPtr) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::execute_on_dest_context(inner, gas_limit, address_offset, value_offset, function_offset, function_length, num_arguments, arguments_length_offset, data_offset))
    }

    fn execute_read_only(&self, gas_limit: i64, address_offset: MemPtr, function_offset: MemPtr, function_length: MemLength, num_arguments: i32, arguments_length_offset: MemPtr, data_offset: MemPtr) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::execute_read_only(inner, gas_limit, address_offset, function_offset, function_length, num_arguments, arguments_length_offset, data_offset))
    }

    fn create_contract(&self, gas_limit: i64, value_offset: MemPtr, code_offset: MemPtr, code_metadata_offset: MemPtr, length: MemLength, result_offset: MemPtr, num_arguments: i32, arguments_length_offset: MemPtr, data_offset: MemPtr) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::create_contract(inner, gas_limit, value_offset, code_offset, code_metadata_offset, length, result_offset, num_arguments, arguments_length_offset, data_offset))
    }

    fn deploy_from_source_contract(&self, gas_limit: i64, value_offset: MemPtr, source_contract_address_offset: MemPtr, code_metadata_offset: MemPtr, result_address_offset: MemPtr, num_arguments: i32, arguments_length_offset: MemPtr, data_offset: MemPtr) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::deploy_from_source_contract(inner, gas_limit, value_offset, source_contract_address_offset, code_metadata_offset, result_address_offset, num_arguments, arguments_length_offset, data_offset))
    }

    fn get_num_return_data(&self) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::get_num_return_data(inner))
    }

    fn get_return_data_size(&self, result_id: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::get_return_data_size(inner, result_id))
    }

    fn get_return_data(&self, result_id: i32, data_offset: MemPtr) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::get_return_data(inner, result_id, data_offset))
    }

    fn clean_return_data(&self) {
        self.adapt_vm_hooks(|inner| VMHooks::clean_return_data(inner))
    }

    fn delete_from_return_data(&self, result_id: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::delete_from_return_data(inner, result_id))
    }

    fn get_original_tx_hash(&self, data_offset: MemPtr) {
        self.adapt_vm_hooks(|inner| VMHooks::get_original_tx_hash(inner, data_offset))
    }

    fn get_current_tx_hash(&self, data_offset: MemPtr) {
        self.adapt_vm_hooks(|inner| VMHooks::get_current_tx_hash(inner, data_offset))
    }

    fn get_prev_tx_hash(&self, data_offset: MemPtr) {
        self.adapt_vm_hooks(|inner| VMHooks::get_prev_tx_hash(inner, data_offset))
    }

    fn managed_sc_address(&self, destination_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::managed_sc_address(inner, destination_handle))
    }

    fn managed_owner_address(&self, destination_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::managed_owner_address(inner, destination_handle))
    }

    fn managed_caller(&self, destination_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::managed_caller(inner, destination_handle))
    }

    fn managed_get_original_caller_addr(&self, destination_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::managed_get_original_caller_addr(inner, destination_handle))
    }

    fn managed_get_relayer_addr(&self, destination_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::managed_get_relayer_addr(inner, destination_handle))
    }

    fn managed_signal_error(&self, err_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::managed_signal_error(inner, err_handle))
    }

    fn managed_write_log(&self, topics_handle: i32, data_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::managed_write_log(inner, topics_handle, data_handle))
    }

    fn managed_get_original_tx_hash(&self, result_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::managed_get_original_tx_hash(inner, result_handle))
    }

    fn managed_get_state_root_hash(&self, result_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::managed_get_state_root_hash(inner, result_handle))
    }

    fn managed_get_block_random_seed(&self, result_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::managed_get_block_random_seed(inner, result_handle))
    }

    fn managed_get_prev_block_random_seed(&self, result_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::managed_get_prev_block_random_seed(inner, result_handle))
    }

    fn managed_get_return_data(&self, result_id: i32, result_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::managed_get_return_data(inner, result_id, result_handle))
    }

    fn managed_get_multi_esdt_call_value(&self, multi_call_value_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::managed_get_multi_esdt_call_value(inner, multi_call_value_handle))
    }

    fn managed_get_all_transfers_call_value(&self, transfer_call_values_list_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::managed_get_all_transfers_call_value(inner, transfer_call_values_list_handle))
    }

    fn managed_get_back_transfers(&self, esdt_transfers_value_handle: i32, egld_value_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::managed_get_back_transfers(inner, esdt_transfers_value_handle, egld_value_handle))
    }

    fn managed_get_esdt_balance(&self, address_handle: i32, token_id_handle: i32, nonce: i64, value_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::managed_get_esdt_balance(inner, address_handle, token_id_handle, nonce, value_handle))
    }

    fn managed_get_esdt_token_data(&self, address_handle: i32, token_id_handle: i32, nonce: i64, value_handle: i32, properties_handle: i32, hash_handle: i32, name_handle: i32, attributes_handle: i32, creator_handle: i32, royalties_handle: i32, uris_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::managed_get_esdt_token_data(inner, address_handle, token_id_handle, nonce, value_handle, properties_handle, hash_handle, name_handle, attributes_handle, creator_handle, royalties_handle, uris_handle))
    }

    fn managed_get_esdt_token_type(&self, address_handle: i32, token_id_handle: i32, nonce: i64, type_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::managed_get_esdt_token_type(inner, address_handle, token_id_handle, nonce, type_handle))
    }

    fn managed_async_call(&self, dest_handle: i32, value_handle: i32, function_handle: i32, arguments_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::managed_async_call(inner, dest_handle, value_handle, function_handle, arguments_handle))
    }

    fn managed_create_async_call(&self, dest_handle: i32, value_handle: i32, function_handle: i32, arguments_handle: i32, success_offset: MemPtr, success_length: MemLength, error_offset: MemPtr, error_length: MemLength, gas: i64, extra_gas_for_callback: i64, callback_closure_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::managed_create_async_call(inner, dest_handle, value_handle, function_handle, arguments_handle, success_offset, success_length, error_offset, error_length, gas, extra_gas_for_callback, callback_closure_handle))
    }

    fn managed_get_callback_closure(&self, callback_closure_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::managed_get_callback_closure(inner, callback_closure_handle))
    }

    fn managed_upgrade_from_source_contract(&self, dest_handle: i32, gas: i64, value_handle: i32, address_handle: i32, code_metadata_handle: i32, arguments_handle: i32, result_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::managed_upgrade_from_source_contract(inner, dest_handle, gas, value_handle, address_handle, code_metadata_handle, arguments_handle, result_handle))
    }

    fn managed_upgrade_contract(&self, dest_handle: i32, gas: i64, value_handle: i32, code_handle: i32, code_metadata_handle: i32, arguments_handle: i32, result_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::managed_upgrade_contract(inner, dest_handle, gas, value_handle, code_handle, code_metadata_handle, arguments_handle, result_handle))
    }

    fn managed_delete_contract(&self, dest_handle: i32, gas_limit: i64, arguments_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::managed_delete_contract(inner, dest_handle, gas_limit, arguments_handle))
    }

    fn managed_deploy_from_source_contract(&self, gas: i64, value_handle: i32, address_handle: i32, code_metadata_handle: i32, arguments_handle: i32, result_address_handle: i32, result_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::managed_deploy_from_source_contract(inner, gas, value_handle, address_handle, code_metadata_handle, arguments_handle, result_address_handle, result_handle))
    }

    fn managed_create_contract(&self, gas: i64, value_handle: i32, code_handle: i32, code_metadata_handle: i32, arguments_handle: i32, result_address_handle: i32, result_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::managed_create_contract(inner, gas, value_handle, code_handle, code_metadata_handle, arguments_handle, result_address_handle, result_handle))
    }

    fn managed_execute_read_only(&self, gas: i64, address_handle: i32, function_handle: i32, arguments_handle: i32, result_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::managed_execute_read_only(inner, gas, address_handle, function_handle, arguments_handle, result_handle))
    }

    fn managed_execute_on_same_context(&self, gas: i64, address_handle: i32, value_handle: i32, function_handle: i32, arguments_handle: i32, result_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::managed_execute_on_same_context(inner, gas, address_handle, value_handle, function_handle, arguments_handle, result_handle))
    }

    fn managed_execute_on_dest_context(&self, gas: i64, address_handle: i32, value_handle: i32, function_handle: i32, arguments_handle: i32, result_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::managed_execute_on_dest_context(inner, gas, address_handle, value_handle, function_handle, arguments_handle, result_handle))
    }

    fn managed_execute_on_dest_context_with_error_return(&self, gas: i64, address_handle: i32, value_handle: i32, function_handle: i32, arguments_handle: i32, result_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::managed_execute_on_dest_context_with_error_return(inner, gas, address_handle, value_handle, function_handle, arguments_handle, result_handle))
    }

    fn managed_multi_transfer_esdt_nft_execute(&self, dst_handle: i32, token_transfers_handle: i32, gas_limit: i64, function_handle: i32, arguments_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::managed_multi_transfer_esdt_nft_execute(inner, dst_handle, token_transfers_handle, gas_limit, function_handle, arguments_handle))
    }

    fn managed_multi_transfer_esdt_nft_execute_with_return(&self, dst_handle: i32, token_transfers_handle: i32, gas_limit: i64, function_handle: i32, arguments_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::managed_multi_transfer_esdt_nft_execute_with_return(inner, dst_handle, token_transfers_handle, gas_limit, function_handle, arguments_handle))
    }

    fn managed_multi_transfer_esdt_nft_execute_by_user(&self, user_handle: i32, dst_handle: i32, token_transfers_handle: i32, gas_limit: i64, function_handle: i32, arguments_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::managed_multi_transfer_esdt_nft_execute_by_user(inner, user_handle, dst_handle, token_transfers_handle, gas_limit, function_handle, arguments_handle))
    }

    fn managed_transfer_value_execute(&self, dst_handle: i32, value_handle: i32, gas_limit: i64, function_handle: i32, arguments_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::managed_transfer_value_execute(inner, dst_handle, value_handle, gas_limit, function_handle, arguments_handle))
    }

    fn managed_is_esdt_frozen(&self, address_handle: i32, token_id_handle: i32, nonce: i64) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::managed_is_esdt_frozen(inner, address_handle, token_id_handle, nonce))
    }

    fn managed_is_esdt_limited_transfer(&self, token_id_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::managed_is_esdt_limited_transfer(inner, token_id_handle))
    }

    fn managed_is_esdt_paused(&self, token_id_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::managed_is_esdt_paused(inner, token_id_handle))
    }

    fn managed_buffer_to_hex(&self, source_handle: i32, dest_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::managed_buffer_to_hex(inner, source_handle, dest_handle))
    }

    fn managed_get_code_metadata(&self, address_handle: i32, response_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::managed_get_code_metadata(inner, address_handle, response_handle))
    }

    fn managed_get_code_hash(&self, address_handle: i32, code_hash_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::managed_get_code_hash(inner, address_handle, code_hash_handle))
    }

    fn managed_is_builtin_function(&self, function_name_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::managed_is_builtin_function(inner, function_name_handle))
    }

    fn big_float_new_from_parts(&self, integral_part: i32, fractional_part: i32, exponent: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::big_float_new_from_parts(inner, integral_part, fractional_part, exponent))
    }

    fn big_float_new_from_frac(&self, numerator: i64, denominator: i64) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::big_float_new_from_frac(inner, numerator, denominator))
    }

    fn big_float_new_from_sci(&self, significand: i64, exponent: i64) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::big_float_new_from_sci(inner, significand, exponent))
    }

    fn big_float_add(&self, destination_handle: i32, op1_handle: i32, op2_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::big_float_add(inner, destination_handle, op1_handle, op2_handle))
    }

    fn big_float_sub(&self, destination_handle: i32, op1_handle: i32, op2_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::big_float_sub(inner, destination_handle, op1_handle, op2_handle))
    }

    fn big_float_mul(&self, destination_handle: i32, op1_handle: i32, op2_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::big_float_mul(inner, destination_handle, op1_handle, op2_handle))
    }

    fn big_float_div(&self, destination_handle: i32, op1_handle: i32, op2_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::big_float_div(inner, destination_handle, op1_handle, op2_handle))
    }

    fn big_float_neg(&self, destination_handle: i32, op_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::big_float_neg(inner, destination_handle, op_handle))
    }

    fn big_float_clone(&self, destination_handle: i32, op_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::big_float_clone(inner, destination_handle, op_handle))
    }

    fn big_float_cmp(&self, op1_handle: i32, op2_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::big_float_cmp(inner, op1_handle, op2_handle))
    }

    fn big_float_abs(&self, destination_handle: i32, op_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::big_float_abs(inner, destination_handle, op_handle))
    }

    fn big_float_sign(&self, op_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::big_float_sign(inner, op_handle))
    }

    fn big_float_sqrt(&self, destination_handle: i32, op_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::big_float_sqrt(inner, destination_handle, op_handle))
    }

    fn big_float_pow(&self, destination_handle: i32, op_handle: i32, exponent: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::big_float_pow(inner, destination_handle, op_handle, exponent))
    }

    fn big_float_floor(&self, dest_big_int_handle: i32, op_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::big_float_floor(inner, dest_big_int_handle, op_handle))
    }

    fn big_float_ceil(&self, dest_big_int_handle: i32, op_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::big_float_ceil(inner, dest_big_int_handle, op_handle))
    }

    fn big_float_truncate(&self, dest_big_int_handle: i32, op_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::big_float_truncate(inner, dest_big_int_handle, op_handle))
    }

    fn big_float_set_int64(&self, destination_handle: i32, value: i64) {
        self.adapt_vm_hooks(|inner| VMHooks::big_float_set_int64(inner, destination_handle, value))
    }

    fn big_float_is_int(&self, op_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::big_float_is_int(inner, op_handle))
    }

    fn big_float_set_big_int(&self, destination_handle: i32, big_int_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::big_float_set_big_int(inner, destination_handle, big_int_handle))
    }

    fn big_float_get_const_pi(&self, destination_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::big_float_get_const_pi(inner, destination_handle))
    }

    fn big_float_get_const_e(&self, destination_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::big_float_get_const_e(inner, destination_handle))
    }

    fn big_int_get_unsigned_argument(&self, id: i32, destination_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::big_int_get_unsigned_argument(inner, id, destination_handle))
    }

    fn big_int_get_signed_argument(&self, id: i32, destination_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::big_int_get_signed_argument(inner, id, destination_handle))
    }

    fn big_int_storage_store_unsigned(&self, key_offset: MemPtr, key_length: MemLength, source_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::big_int_storage_store_unsigned(inner, key_offset, key_length, source_handle))
    }

    fn big_int_storage_load_unsigned(&self, key_offset: MemPtr, key_length: MemLength, destination_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::big_int_storage_load_unsigned(inner, key_offset, key_length, destination_handle))
    }

    fn big_int_get_call_value(&self, destination_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::big_int_get_call_value(inner, destination_handle))
    }

    fn big_int_get_esdt_call_value(&self, destination: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::big_int_get_esdt_call_value(inner, destination))
    }

    fn big_int_get_esdt_call_value_by_index(&self, destination_handle: i32, index: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::big_int_get_esdt_call_value_by_index(inner, destination_handle, index))
    }

    fn big_int_get_external_balance(&self, address_offset: MemPtr, result: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::big_int_get_external_balance(inner, address_offset, result))
    }

    fn big_int_get_esdt_external_balance(&self, address_offset: MemPtr, token_id_offset: MemPtr, token_id_len: MemLength, nonce: i64, result_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::big_int_get_esdt_external_balance(inner, address_offset, token_id_offset, token_id_len, nonce, result_handle))
    }

    fn big_int_new(&self, small_value: i64) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::big_int_new(inner, small_value))
    }

    fn big_int_unsigned_byte_length(&self, reference_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::big_int_unsigned_byte_length(inner, reference_handle))
    }

    fn big_int_signed_byte_length(&self, reference_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::big_int_signed_byte_length(inner, reference_handle))
    }

    fn big_int_get_unsigned_bytes(&self, reference_handle: i32, byte_offset: MemPtr) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::big_int_get_unsigned_bytes(inner, reference_handle, byte_offset))
    }

    fn big_int_get_signed_bytes(&self, reference_handle: i32, byte_offset: MemPtr) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::big_int_get_signed_bytes(inner, reference_handle, byte_offset))
    }

    fn big_int_set_unsigned_bytes(&self, destination_handle: i32, byte_offset: MemPtr, byte_length: MemLength) {
        self.adapt_vm_hooks(|inner| VMHooks::big_int_set_unsigned_bytes(inner, destination_handle, byte_offset, byte_length))
    }

    fn big_int_set_signed_bytes(&self, destination_handle: i32, byte_offset: MemPtr, byte_length: MemLength) {
        self.adapt_vm_hooks(|inner| VMHooks::big_int_set_signed_bytes(inner, destination_handle, byte_offset, byte_length))
    }

    fn big_int_is_int64(&self, destination_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::big_int_is_int64(inner, destination_handle))
    }

    fn big_int_get_int64(&self, destination_handle: i32) -> i64 {
        self.adapt_vm_hooks(|inner| VMHooks::big_int_get_int64(inner, destination_handle))
    }

    fn big_int_set_int64(&self, destination_handle: i32, value: i64) {
        self.adapt_vm_hooks(|inner| VMHooks::big_int_set_int64(inner, destination_handle, value))
    }

    fn big_int_add(&self, destination_handle: i32, op1_handle: i32, op2_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::big_int_add(inner, destination_handle, op1_handle, op2_handle))
    }

    fn big_int_sub(&self, destination_handle: i32, op1_handle: i32, op2_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::big_int_sub(inner, destination_handle, op1_handle, op2_handle))
    }

    fn big_int_mul(&self, destination_handle: i32, op1_handle: i32, op2_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::big_int_mul(inner, destination_handle, op1_handle, op2_handle))
    }

    fn big_int_tdiv(&self, destination_handle: i32, op1_handle: i32, op2_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::big_int_tdiv(inner, destination_handle, op1_handle, op2_handle))
    }

    fn big_int_tmod(&self, destination_handle: i32, op1_handle: i32, op2_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::big_int_tmod(inner, destination_handle, op1_handle, op2_handle))
    }

    fn big_int_ediv(&self, destination_handle: i32, op1_handle: i32, op2_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::big_int_ediv(inner, destination_handle, op1_handle, op2_handle))
    }

    fn big_int_emod(&self, destination_handle: i32, op1_handle: i32, op2_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::big_int_emod(inner, destination_handle, op1_handle, op2_handle))
    }

    fn big_int_sqrt(&self, destination_handle: i32, op_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::big_int_sqrt(inner, destination_handle, op_handle))
    }

    fn big_int_pow(&self, destination_handle: i32, op1_handle: i32, op2_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::big_int_pow(inner, destination_handle, op1_handle, op2_handle))
    }

    fn big_int_log2(&self, op1_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::big_int_log2(inner, op1_handle))
    }

    fn big_int_abs(&self, destination_handle: i32, op_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::big_int_abs(inner, destination_handle, op_handle))
    }

    fn big_int_neg(&self, destination_handle: i32, op_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::big_int_neg(inner, destination_handle, op_handle))
    }

    fn big_int_sign(&self, op_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::big_int_sign(inner, op_handle))
    }

    fn big_int_cmp(&self, op1_handle: i32, op2_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::big_int_cmp(inner, op1_handle, op2_handle))
    }

    fn big_int_not(&self, destination_handle: i32, op_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::big_int_not(inner, destination_handle, op_handle))
    }

    fn big_int_and(&self, destination_handle: i32, op1_handle: i32, op2_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::big_int_and(inner, destination_handle, op1_handle, op2_handle))
    }

    fn big_int_or(&self, destination_handle: i32, op1_handle: i32, op2_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::big_int_or(inner, destination_handle, op1_handle, op2_handle))
    }

    fn big_int_xor(&self, destination_handle: i32, op1_handle: i32, op2_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::big_int_xor(inner, destination_handle, op1_handle, op2_handle))
    }

    fn big_int_shr(&self, destination_handle: i32, op_handle: i32, bits: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::big_int_shr(inner, destination_handle, op_handle, bits))
    }

    fn big_int_shl(&self, destination_handle: i32, op_handle: i32, bits: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::big_int_shl(inner, destination_handle, op_handle, bits))
    }

    fn big_int_finish_unsigned(&self, reference_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::big_int_finish_unsigned(inner, reference_handle))
    }

    fn big_int_finish_signed(&self, reference_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::big_int_finish_signed(inner, reference_handle))
    }

    fn big_int_to_string(&self, big_int_handle: i32, destination_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::big_int_to_string(inner, big_int_handle, destination_handle))
    }

    fn mbuffer_new(&self) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::mbuffer_new(inner))
    }

    fn mbuffer_new_from_bytes(&self, data_offset: MemPtr, data_length: MemLength) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::mbuffer_new_from_bytes(inner, data_offset, data_length))
    }

    fn mbuffer_get_length(&self, m_buffer_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::mbuffer_get_length(inner, m_buffer_handle))
    }

    fn mbuffer_get_bytes(&self, m_buffer_handle: i32, result_offset: MemPtr) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::mbuffer_get_bytes(inner, m_buffer_handle, result_offset))
    }

    fn mbuffer_get_byte_slice(&self, source_handle: i32, starting_position: i32, slice_length: i32, result_offset: MemPtr) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::mbuffer_get_byte_slice(inner, source_handle, starting_position, slice_length, result_offset))
    }

    fn mbuffer_copy_byte_slice(&self, source_handle: i32, starting_position: i32, slice_length: i32, destination_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::mbuffer_copy_byte_slice(inner, source_handle, starting_position, slice_length, destination_handle))
    }

    fn mbuffer_eq(&self, m_buffer_handle1: i32, m_buffer_handle2: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::mbuffer_eq(inner, m_buffer_handle1, m_buffer_handle2))
    }

    fn mbuffer_set_bytes(&self, m_buffer_handle: i32, data_offset: MemPtr, data_length: MemLength) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::mbuffer_set_bytes(inner, m_buffer_handle, data_offset, data_length))
    }

    fn mbuffer_set_byte_slice(&self, m_buffer_handle: i32, starting_position: i32, data_length: MemLength, data_offset: MemPtr) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::mbuffer_set_byte_slice(inner, m_buffer_handle, starting_position, data_length, data_offset))
    }

    fn mbuffer_append(&self, accumulator_handle: i32, data_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::mbuffer_append(inner, accumulator_handle, data_handle))
    }

    fn mbuffer_append_bytes(&self, accumulator_handle: i32, data_offset: MemPtr, data_length: MemLength) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::mbuffer_append_bytes(inner, accumulator_handle, data_offset, data_length))
    }

    fn mbuffer_to_big_int_unsigned(&self, m_buffer_handle: i32, big_int_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::mbuffer_to_big_int_unsigned(inner, m_buffer_handle, big_int_handle))
    }

    fn mbuffer_to_big_int_signed(&self, m_buffer_handle: i32, big_int_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::mbuffer_to_big_int_signed(inner, m_buffer_handle, big_int_handle))
    }

    fn mbuffer_from_big_int_unsigned(&self, m_buffer_handle: i32, big_int_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::mbuffer_from_big_int_unsigned(inner, m_buffer_handle, big_int_handle))
    }

    fn mbuffer_from_big_int_signed(&self, m_buffer_handle: i32, big_int_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::mbuffer_from_big_int_signed(inner, m_buffer_handle, big_int_handle))
    }

    fn mbuffer_to_small_int_unsigned(&self, m_buffer_handle: i32) -> i64 {
        self.adapt_vm_hooks(|inner| VMHooks::mbuffer_to_small_int_unsigned(inner, m_buffer_handle))
    }

    fn mbuffer_to_small_int_signed(&self, m_buffer_handle: i32) -> i64 {
        self.adapt_vm_hooks(|inner| VMHooks::mbuffer_to_small_int_signed(inner, m_buffer_handle))
    }

    fn mbuffer_from_small_int_unsigned(&self, m_buffer_handle: i32, value: i64) {
        self.adapt_vm_hooks(|inner| VMHooks::mbuffer_from_small_int_unsigned(inner, m_buffer_handle, value))
    }

    fn mbuffer_from_small_int_signed(&self, m_buffer_handle: i32, value: i64) {
        self.adapt_vm_hooks(|inner| VMHooks::mbuffer_from_small_int_signed(inner, m_buffer_handle, value))
    }

    fn mbuffer_to_big_float(&self, m_buffer_handle: i32, big_float_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::mbuffer_to_big_float(inner, m_buffer_handle, big_float_handle))
    }

    fn mbuffer_from_big_float(&self, m_buffer_handle: i32, big_float_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::mbuffer_from_big_float(inner, m_buffer_handle, big_float_handle))
    }

    fn mbuffer_storage_store(&self, key_handle: i32, source_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::mbuffer_storage_store(inner, key_handle, source_handle))
    }

    fn mbuffer_storage_load(&self, key_handle: i32, destination_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::mbuffer_storage_load(inner, key_handle, destination_handle))
    }

    fn mbuffer_storage_load_from_address(&self, address_handle: i32, key_handle: i32, destination_handle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::mbuffer_storage_load_from_address(inner, address_handle, key_handle, destination_handle))
    }

    fn mbuffer_get_argument(&self, id: i32, destination_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::mbuffer_get_argument(inner, id, destination_handle))
    }

    fn mbuffer_finish(&self, source_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::mbuffer_finish(inner, source_handle))
    }

    fn mbuffer_set_random(&self, destination_handle: i32, length: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::mbuffer_set_random(inner, destination_handle, length))
    }

    fn managed_map_new(&self) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::managed_map_new(inner))
    }

    fn managed_map_put(&self, m_map_handle: i32, key_handle: i32, value_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::managed_map_put(inner, m_map_handle, key_handle, value_handle))
    }

    fn managed_map_get(&self, m_map_handle: i32, key_handle: i32, out_value_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::managed_map_get(inner, m_map_handle, key_handle, out_value_handle))
    }

    fn managed_map_remove(&self, m_map_handle: i32, key_handle: i32, out_value_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::managed_map_remove(inner, m_map_handle, key_handle, out_value_handle))
    }

    fn managed_map_contains(&self, m_map_handle: i32, key_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::managed_map_contains(inner, m_map_handle, key_handle))
    }

    fn small_int_get_unsigned_argument(&self, id: i32) -> i64 {
        self.adapt_vm_hooks(|inner| VMHooks::small_int_get_unsigned_argument(inner, id))
    }

    fn small_int_get_signed_argument(&self, id: i32) -> i64 {
        self.adapt_vm_hooks(|inner| VMHooks::small_int_get_signed_argument(inner, id))
    }

    fn small_int_finish_unsigned(&self, value: i64) {
        self.adapt_vm_hooks(|inner| VMHooks::small_int_finish_unsigned(inner, value))
    }

    fn small_int_finish_signed(&self, value: i64) {
        self.adapt_vm_hooks(|inner| VMHooks::small_int_finish_signed(inner, value))
    }

    fn small_int_storage_store_unsigned(&self, key_offset: MemPtr, key_length: MemLength, value: i64) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::small_int_storage_store_unsigned(inner, key_offset, key_length, value))
    }

    fn small_int_storage_store_signed(&self, key_offset: MemPtr, key_length: MemLength, value: i64) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::small_int_storage_store_signed(inner, key_offset, key_length, value))
    }

    fn small_int_storage_load_unsigned(&self, key_offset: MemPtr, key_length: MemLength) -> i64 {
        self.adapt_vm_hooks(|inner| VMHooks::small_int_storage_load_unsigned(inner, key_offset, key_length))
    }

    fn small_int_storage_load_signed(&self, key_offset: MemPtr, key_length: MemLength) -> i64 {
        self.adapt_vm_hooks(|inner| VMHooks::small_int_storage_load_signed(inner, key_offset, key_length))
    }

    fn int64get_argument(&self, id: i32) -> i64 {
        self.adapt_vm_hooks(|inner| VMHooks::int64get_argument(inner, id))
    }

    fn int64finish(&self, value: i64) {
        self.adapt_vm_hooks(|inner| VMHooks::int64finish(inner, value))
    }

    fn int64storage_store(&self, key_offset: MemPtr, key_length: MemLength, value: i64) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::int64storage_store(inner, key_offset, key_length, value))
    }

    fn int64storage_load(&self, key_offset: MemPtr, key_length: MemLength) -> i64 {
        self.adapt_vm_hooks(|inner| VMHooks::int64storage_load(inner, key_offset, key_length))
    }

    fn sha256(&self, data_offset: MemPtr, length: MemLength, result_offset: MemPtr) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::sha256(inner, data_offset, length, result_offset))
    }

    fn managed_sha256(&self, input_handle: i32, output_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::managed_sha256(inner, input_handle, output_handle))
    }

    fn keccak256(&self, data_offset: MemPtr, length: MemLength, result_offset: MemPtr) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::keccak256(inner, data_offset, length, result_offset))
    }

    fn managed_keccak256(&self, input_handle: i32, output_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::managed_keccak256(inner, input_handle, output_handle))
    }

    fn ripemd160(&self, data_offset: MemPtr, length: MemLength, result_offset: MemPtr) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::ripemd160(inner, data_offset, length, result_offset))
    }

    fn managed_ripemd160(&self, input_handle: i32, output_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::managed_ripemd160(inner, input_handle, output_handle))
    }

    fn verify_bls(&self, key_offset: MemPtr, message_offset: MemPtr, message_length: MemLength, sig_offset: MemPtr) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::verify_bls(inner, key_offset, message_offset, message_length, sig_offset))
    }

    fn managed_verify_bls(&self, key_handle: i32, message_handle: i32, sig_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::managed_verify_bls(inner, key_handle, message_handle, sig_handle))
    }

    fn verify_ed25519(&self, key_offset: MemPtr, message_offset: MemPtr, message_length: MemLength, sig_offset: MemPtr) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::verify_ed25519(inner, key_offset, message_offset, message_length, sig_offset))
    }

    fn managed_verify_ed25519(&self, key_handle: i32, message_handle: i32, sig_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::managed_verify_ed25519(inner, key_handle, message_handle, sig_handle))
    }

    fn verify_custom_secp256k1(&self, key_offset: MemPtr, key_length: MemLength, message_offset: MemPtr, message_length: MemLength, sig_offset: MemPtr, hash_type: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::verify_custom_secp256k1(inner, key_offset, key_length, message_offset, message_length, sig_offset, hash_type))
    }

    fn managed_verify_custom_secp256k1(&self, key_handle: i32, message_handle: i32, sig_handle: i32, hash_type: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::managed_verify_custom_secp256k1(inner, key_handle, message_handle, sig_handle, hash_type))
    }

    fn verify_secp256k1(&self, key_offset: MemPtr, key_length: MemLength, message_offset: MemPtr, message_length: MemLength, sig_offset: MemPtr) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::verify_secp256k1(inner, key_offset, key_length, message_offset, message_length, sig_offset))
    }

    fn managed_verify_secp256k1(&self, key_handle: i32, message_handle: i32, sig_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::managed_verify_secp256k1(inner, key_handle, message_handle, sig_handle))
    }

    fn encode_secp256k1_der_signature(&self, r_offset: MemPtr, r_length: MemLength, s_offset: MemPtr, s_length: MemLength, sig_offset: MemPtr) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::encode_secp256k1_der_signature(inner, r_offset, r_length, s_offset, s_length, sig_offset))
    }

    fn managed_encode_secp256k1_der_signature(&self, r_handle: i32, s_handle: i32, sig_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::managed_encode_secp256k1_der_signature(inner, r_handle, s_handle, sig_handle))
    }

    fn add_ec(&self, x_result_handle: i32, y_result_handle: i32, ec_handle: i32, fst_point_xhandle: i32, fst_point_yhandle: i32, snd_point_xhandle: i32, snd_point_yhandle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::add_ec(inner, x_result_handle, y_result_handle, ec_handle, fst_point_xhandle, fst_point_yhandle, snd_point_xhandle, snd_point_yhandle))
    }

    fn double_ec(&self, x_result_handle: i32, y_result_handle: i32, ec_handle: i32, point_xhandle: i32, point_yhandle: i32) {
        self.adapt_vm_hooks(|inner| VMHooks::double_ec(inner, x_result_handle, y_result_handle, ec_handle, point_xhandle, point_yhandle))
    }

    fn is_on_curve_ec(&self, ec_handle: i32, point_xhandle: i32, point_yhandle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::is_on_curve_ec(inner, ec_handle, point_xhandle, point_yhandle))
    }

    fn scalar_base_mult_ec(&self, x_result_handle: i32, y_result_handle: i32, ec_handle: i32, data_offset: MemPtr, length: MemLength) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::scalar_base_mult_ec(inner, x_result_handle, y_result_handle, ec_handle, data_offset, length))
    }

    fn managed_scalar_base_mult_ec(&self, x_result_handle: i32, y_result_handle: i32, ec_handle: i32, data_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::managed_scalar_base_mult_ec(inner, x_result_handle, y_result_handle, ec_handle, data_handle))
    }

    fn scalar_mult_ec(&self, x_result_handle: i32, y_result_handle: i32, ec_handle: i32, point_xhandle: i32, point_yhandle: i32, data_offset: MemPtr, length: MemLength) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::scalar_mult_ec(inner, x_result_handle, y_result_handle, ec_handle, point_xhandle, point_yhandle, data_offset, length))
    }

    fn managed_scalar_mult_ec(&self, x_result_handle: i32, y_result_handle: i32, ec_handle: i32, point_xhandle: i32, point_yhandle: i32, data_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::managed_scalar_mult_ec(inner, x_result_handle, y_result_handle, ec_handle, point_xhandle, point_yhandle, data_handle))
    }

    fn marshal_ec(&self, x_pair_handle: i32, y_pair_handle: i32, ec_handle: i32, result_offset: MemPtr) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::marshal_ec(inner, x_pair_handle, y_pair_handle, ec_handle, result_offset))
    }

    fn managed_marshal_ec(&self, x_pair_handle: i32, y_pair_handle: i32, ec_handle: i32, result_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::managed_marshal_ec(inner, x_pair_handle, y_pair_handle, ec_handle, result_handle))
    }

    fn marshal_compressed_ec(&self, x_pair_handle: i32, y_pair_handle: i32, ec_handle: i32, result_offset: MemPtr) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::marshal_compressed_ec(inner, x_pair_handle, y_pair_handle, ec_handle, result_offset))
    }

    fn managed_marshal_compressed_ec(&self, x_pair_handle: i32, y_pair_handle: i32, ec_handle: i32, result_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::managed_marshal_compressed_ec(inner, x_pair_handle, y_pair_handle, ec_handle, result_handle))
    }

    fn unmarshal_ec(&self, x_result_handle: i32, y_result_handle: i32, ec_handle: i32, data_offset: MemPtr, length: MemLength) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::unmarshal_ec(inner, x_result_handle, y_result_handle, ec_handle, data_offset, length))
    }

    fn managed_unmarshal_ec(&self, x_result_handle: i32, y_result_handle: i32, ec_handle: i32, data_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::managed_unmarshal_ec(inner, x_result_handle, y_result_handle, ec_handle, data_handle))
    }

    fn unmarshal_compressed_ec(&self, x_result_handle: i32, y_result_handle: i32, ec_handle: i32, data_offset: MemPtr, length: MemLength) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::unmarshal_compressed_ec(inner, x_result_handle, y_result_handle, ec_handle, data_offset, length))
    }

    fn managed_unmarshal_compressed_ec(&self, x_result_handle: i32, y_result_handle: i32, ec_handle: i32, data_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::managed_unmarshal_compressed_ec(inner, x_result_handle, y_result_handle, ec_handle, data_handle))
    }

    fn generate_key_ec(&self, x_pub_key_handle: i32, y_pub_key_handle: i32, ec_handle: i32, result_offset: MemPtr) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::generate_key_ec(inner, x_pub_key_handle, y_pub_key_handle, ec_handle, result_offset))
    }

    fn managed_generate_key_ec(&self, x_pub_key_handle: i32, y_pub_key_handle: i32, ec_handle: i32, result_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::managed_generate_key_ec(inner, x_pub_key_handle, y_pub_key_handle, ec_handle, result_handle))
    }

    fn create_ec(&self, data_offset: MemPtr, data_length: MemLength) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::create_ec(inner, data_offset, data_length))
    }

    fn managed_create_ec(&self, data_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::managed_create_ec(inner, data_handle))
    }

    fn get_curve_length_ec(&self, ec_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::get_curve_length_ec(inner, ec_handle))
    }

    fn get_priv_key_byte_length_ec(&self, ec_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::get_priv_key_byte_length_ec(inner, ec_handle))
    }

    fn elliptic_curve_get_values(&self, ec_handle: i32, field_order_handle: i32, base_point_order_handle: i32, eq_constant_handle: i32, x_base_point_handle: i32, y_base_point_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::elliptic_curve_get_values(inner, ec_handle, field_order_handle, base_point_order_handle, eq_constant_handle, x_base_point_handle, y_base_point_handle))
    }

    fn managed_verify_secp256r1(&self, key_handle: i32, message_handle: i32, sig_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::managed_verify_secp256r1(inner, key_handle, message_handle, sig_handle))
    }

    fn managed_verify_blssignature_share(&self, key_handle: i32, message_handle: i32, sig_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::managed_verify_blssignature_share(inner, key_handle, message_handle, sig_handle))
    }

    fn managed_verify_blsaggregated_signature(&self, key_handle: i32, message_handle: i32, sig_handle: i32) -> i32 {
        self.adapt_vm_hooks(|inner| VMHooks::managed_verify_blsaggregated_signature(inner, key_handle, message_handle, sig_handle))
    }
}
